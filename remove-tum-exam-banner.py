#! /usr/bin/env nix-shell
#! nix-shell -i python3 -p python3Packages.pymupdf

# This script attempts to remove visual banners from PDF files,
# specifically those that may appear on exams generated by the tumexam system
# used at the Technical University of Munich (TUM).
#
# DISCLAIMER:
# This script is provided "as-is" without any warranty, express or implied.
# Use it entirely at your own risk. The author(s) and/or distributor(s)
# are not responsible for any damage or unintended consequences that may
# arise from its use, including but not limited to corrupted files or
# inaccurate modifications.
#
# ACADEMIC INTEGRITY & PRIVACY:
# Remember to respect academic integrity policies and privacy.
# Do not share exam materials publicly or in any way that violates
# university regulations or copyright. This tool is intended for
# personal convenience in viewing or archiving your own materials.

import fitz
import sys
import os
import re

# Regex for banner's core drawing sequence
rgx = re.compile(
    rb"(q\s*"  # Save state
    rb"[\d\.\-eE]+\s+[\d\.\-eE]+\s+[\d\.\-eE]+\s+[\d\.\-eE]+\s+0\s+0\s+cm\s+"  # Rotation CTM
    rb"0\.8\s+0\.8\s+1\s+rg)"  # Fill color
)


def process_pdf(in_f, out_f):
    doc = None
    try:
        doc = fitz.open(in_f)
        mod_c = 0  # Modification count

        for page_idx in range(len(doc)):
            page = doc.load_page(page_idx)
            xrefs = page.get_contents()
            if not xrefs:
                continue

            for xref_val in xrefs:
                stream_data = doc.xref_stream(xref_val)
                if not stream_data:
                    continue

                # Work on a mutable copy
                content_arr = bytearray(stream_data)
                original_len = len(content_arr)

                while True:  # Loop to remove multiple occurrences in one stream
                    match_obj = rgx.search(content_arr)
                    if not match_obj:
                        break

                    q_op_start = match_obj.start()  # Index of 'q'

                    # Balance q/Q to find the end of this block
                    q_lvl = 0
                    current_idx = q_op_start
                    q_op_end = -1

                    while current_idx < len(content_arr):
                        char_byte = content_arr[current_idx]
                        # Check for typical PDF operator delimiters
                        delim_follows = (current_idx + 1 < len(content_arr)) and (
                            content_arr[current_idx + 1] in (ord(b" "), ord(b"\n"))
                        )

                        if char_byte == ord(b"q") and delim_follows:
                            q_lvl += 1
                            current_idx += (
                                1  # Consume 'q', main loop increment will get delimiter
                            )
                        elif char_byte == ord(b"Q") and delim_follows:
                            q_lvl -= 1
                            if q_lvl == 0:  # Matched the initial 'q'
                                q_op_end = (
                                    current_idx + 2
                                )  # Include 'Q' and its delimiter
                                break
                            current_idx += 1  # Consume 'Q'
                        current_idx += 1  # General advance

                    if q_op_end != -1:
                        # Replace the block
                        content_arr = (
                            content_arr[:q_op_start]
                            + b" %RM\n"
                            + content_arr[q_op_end:]
                        )
                        mod_c += 1
                    else:
                        # Malformed or unmatched q/Q, stop for this stream
                        break

                if len(content_arr) != original_len:
                    doc.update_stream(xref_val, bytes(content_arr))

        # Save, using clean=True only if changes were made
        doc.save(out_f, garbage=3, deflate=True, clean=(mod_c > 0))
        print(f"{out_f}")

    except Exception as e_val:
        sys.stderr.write(f"Error: {e_val}\n")
        sys.exit(1)
    finally:
        if doc:
            doc.close()


# --- Script execution ---
if len(sys.argv) < 3:
    sys.stderr.write(f"Usage: {os.path.basename(__file__)} <input.pdf> <output.pdf>\n")
    sys.exit(1)

in_path, out_path = sys.argv[1], sys.argv[2]

if not os.path.isfile(in_path):
    sys.stderr.write(f"Input not found: {in_path}\n")
    sys.exit(1)

process_pdf(in_path, out_path)
